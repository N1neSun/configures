		"基础设置
set nocompatible		"不兼容vi
set nu
set ruler
set incsearch		"逐字高亮搜索
set matchtime=5		"高亮的时间
syntax enable		"语法高亮
set history=500  	"vim记住的历史操作的数量，默认的是20
set go=
set wildmenu
set nofen
set fdl=10			 "始终启用鼠标
set mouse=a
		" 状态条，显示字节数，列数，行数，当前行等信息	
"set statusline=%F%m%r%h%w/ [FORMAT=%{&ff}]/ [TYPE=%Y]/ [ASCII=/%03.3b]/ [HEX=/%02.2B]/ [POS=%04l,%04v][%p%%]/ [LEN=%L]
"set laststatus=2 	"always show the status line
"set shortmess=atI	"去掉欢迎界面
"set lines=28  columns=200		"窗口大小
"colorscheme desert				"主题
"set textwidth=80				"文本行的长度，需要开启自动换行
"set cursorline					"高亮当前
		"字符编码"
set fileencodings=utf-8,gbk,gb2312,cp936
set fileencoding=utf-8		"可以不用设置
"set encoding=utf-8			"设置状态栏的编码，可以不设置
autocmd filetype txt set spell			"对txt文档的英文进行语法检查
"set spell								"开启拼写检查
" 基于缩进或语法进行折叠
set foldmethod=indent	"基于缩进
"set foldmethod=syntax|mnual手动
"启动vim时关闭代码折叠
"set nofoldenable
set foldenable
"空格折叠
nnoremap <space> @=((foldclosed(line('.')) < 0) ? 'zc' : 'zo')<CR>
"深入7层自动折叠
set foldlevel=7
		"没明白的设置
filetype on		"侦测文件类型

"===========================================================
"gvim的设置在.gvimrc中
"===========================================================
"set guifont=Consolas:h12		"字体中有空格用\来转意,这条是win下的写法


		"关于C语言的设置
set cindent					"C语言缩进
"set list listchars=tab:>-	"可视化tab键
set noexpandtab				"不用空格替代tab,(%retab!空格转换为tab)
set autoindent				"继承上一缩进
set si						"智能缩进
set tabstop=4 shiftwidth=4	"shiftwidth自动tab宽度
autocmd filetype xhtml set tabstop=2 shiftwidth=2
autocmd filetype html set tabstop=2 shiftwidth=2
autocmd filetype lisp set nocindent autoindent si
"autocmd filetype c set tabstop=4 shiftwidth=4
"autocmd filetype h set tabstop=4 shiftwidth=4
"autocmd filetype c++ set tabstop=4 shiftwidth=4
"autocmd filetype py set noexpandtab tabstop=4 shiftwidth=4
set completeopt=menu		"补全不显示草稿窗口

"<F3>实现sdcv快捷查询
function! Mydict()
	let expl=system('sdcv -n ' .
	\  expand("<cword>"))
	windo if
	\ expand("%")=="diCt-tmp" |
	\ q!|endif
	30vsp diCt-tmp
	setlocal buftype=nofile bufhidden=hide noswapfile
	1s/^/\=expl/
	1
endfunction
nmap <F3> :call Mydict()<CR>

"<F4>编译"
map <F4> : call Compile()<CR>
func! Compile()
	exec "w"
	if &filetype == 'c'				"c
		exec "!clear"
		exec "!gcc -o '%<' '%' -ansi -Wall -lm"
	elseif &filetype == 'cpp'		"cpp
		exec "!clear"
		exec "!g++ -o '%<' '%'"
	elseif &filetype == 'java'		"java
		exec "!clear"
		exec "!javac '%'"
	elseif &filetype == 'asm'		"汇编
		exec "!clear"
		exec "!as '%' -o '%<.o' && ld '%<.o' -o '%<'"
	elseif &filetype == 'cs'		"c_sharp
		exec "!clear"
		exec "!gmcs '%'"
	elseif &filetype == 'tex'		"tex文件
		exec "!clear"
		"这里使用texlive的包,以后修改
		exec "!xelatex '%'"
	else
		exec ""
	endif
endfunc


"<F5>编译运行"
map <F5> :call CompileRun()<CR>
func! CompileRun()
	exec "w"
	if &filetype == 'xhtml' || &filetype == 'html'	"html
		exec "!clear"
		exec "!firefox '%'"
	elseif &filetype == 'c'		"c
		exec "!clear"
		exec "!gcc -o '%<' '%' -Wall -ansi -lm"
		exec "!./%<"
	elseif &filetype == 'cpp'	"cpp
		exec "!clear"
		exec "!g++ -o '%<' '%'"
		exec "!./%<"
	elseif &filetype == 'java'	"java
		exec "!clear"
		exec "!javac '%'; java '%<'"
	elseif &filetype == 'asm'	"汇编
		exec "!clear"
		exec "!as '%' -o '%<.o' && ld '%<.o' -o '%<'"
		exec "!./'%<'"
	elseif &filetype == 'cs'	"c_sharp
		exec "!clear"
		exec "!gmcs '%'; ./'%<.exe'"
	elseif &filetype == 'python' "python
		exec "!clear"
		exec "!python '%'"
	elseif &filetype == 'tex'		"tex文件
		exec "!clear"
		exec "!xelatex '%'"
		"使用evince打开
		exec "!evince '%<.pdf'"
	else
		exec ""
	endif
endfunc

"<F6>运行"
map <F6> : call Run()<CR>
func! Run()
	exec "w"
	"C或者汇编
	if &filetype == 'c' || &filetype == 'asm' || &filetype == 'cpp'
		exec "!clear"
		exec "!./'%<'"
	elseif &filetype == 'java'	"java
		exec "!clear"
		exec "!java '%<'"
	elseif &filetype == 'cs'	"c_sharp
		exec "!clear"
		exec "!./'%<.exe'"
	else
		exec ""
	endif
endfunc

"C语言调试"
map <F7> : call GDB()<CR>
func! GDB()
	exec "w"
	if &filetype == 'c'			"c
		exec "!clear"
		exec "!gcc -o %< % -g -ansi -lm"
		exec "!gdb %<"
	elseif &filetype == 'cpp'		"cpp
		exec "!clear"
		exec "!g++ -o %< % -g"
		exec "!gdb %<"
	elseif &filetype == 'asm'	"汇编
		exec "!clear"
		exec "!as % -g -o %<.o && ld %<.o -o %<"
		exec "!gdb %<"
	elseif &filetype == 'java'	"java
		exec "!clear"
		exec "!javac -g '%'"
		exec "!jdb '%<'"
	elseif &filetype == 'cs'	"c_sharp
		exec "!clear"
	else
		exec ""
	endif
endfunc

"生成tags和cscope
map <F8> : call C_ctags_cs()<CR>
func! C_ctags_cs()
	if &filetype == 'c' || &filetype == 'h'	"只对c实行生成ctags
		exec "!ctags -R"
		"对cscope生成的数据库就放在这个目录下
		exec "!cscope -Rkbq"
		if filereadable("cscope.out")
			cs add cscope.out
		elseif "$CSCOPE_DB" != ""
			cs add "$CSCOPE_DB"
		endif
	endif
endfunc
"cscope配置
set cscopequickfix=s-,c-,d-,i-,t-,e-
set cst
set csto=1	"先搜索ctags文件
if filereadable("cscope.out")
	cs add cscope.out
endif
"使用同ctags，cscope -Rbq
"添加数据库
""USE:添加快捷键
"nmap <C-@>s :cs find s <C-R>=expand("<cword>")<CR><CR>
"nmap <C-@>g :cs find g <C-R>=expand("<cword>")<CR><CR>
"nmap <C-@>c :cs find c <C-R>=expand("<cword>")<CR><CR>
"nmap <C-@>t :cs find t <C-R>=expand("<cword>")<CR><CR>
"nmap <C-@>e :cs find e <C-R>=expand("<cword>")<CR><CR>
"nmap <C-@>f :cs find f <C-R>=expand("<cword>")<CR><CR>
"nmap <C-@>i :cs find i ^<C-R>=expand("<cword>")<CR>$<CR>
"nmap <C-@>d :cs find d <C-R>=expand("<cword>")<CR><CR>
""===end cscope===

"使用vbundle来管理插件
"启动智能补全
filetype plugin indent on
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()
"required!
Bundle 'gmarik/vundle'
Bundle 'bling/vim-airline'
"Bundle 'Lokaltog/vim-powerline'
Bundle 'HTML-AutoCloseTag'
Bundle 'hail2u/vim-css3-syntax'
Bundle 'mattn/emmet-vim'
"NERD commenter,下面的AuthorInfo需要
Bundle 'scrooloose/nerdcommenter'
"添加作者信息
Bundle 'vim-scripts/AuthorInfo'
Bundle 'Shougo/neocomplete'
Bundle 'bling/vim-bufferline'
"Bundle 'vim-scripts/VimIM'
Bundle 'scrooloose/nerdtree'
Bundle 'majutsushi/tagbar'
"vim中文帮助
Bundle 'yianwillis/vimcdoc'
"java补全
"Bundle 'artur-shaik/vim-javacomplete2'
"tex补全
Bundle 'lervag/vimtex'
"...
"下面是vundle使用命令
":BundleList			--list configured bundles
":BundleInstall(!)		--install(update) bundles
":BundleSearch(!) foo	--search(or refresh cache first) for foo
":BundleClean(!)		--confirm(or auto-approve) removal of unused bundles
"see ':h vundle' for more details or wiki for FAQ


"NOTE 整合
"左边文件管理，右边tagbar
"USE: 在普通模式下输入 vm
nmap wm : call NerdTree_TagBar_Toggle()<cr>
function! NerdTree_TagBar_Toggle()
	exec "NERDTreeToggle"
	exec "TagbarToggle"
endfunction

"set completeopt=longest,menu
"下面是使用了supertab插件来优化补全
"let g:SuperTabRetainCompletionType=2
" 0 - 不记录上次的补全方式
" 1 - 记住上次的补全方式,直到用其他的补全命令改变它
" 2 - 记住上次的补全方式,直到按ESC退出插入模式为止

"let g:SuperTabDefaultCompletionType="<C-X><C-O>"
" 设置按下<Tab>后默认的补全方式, 默认是<C-P>,
" 现在改为<C-X><C-O>. 关于<C-P>的补全方式,
" USE:
" 	:help ins-completion
" 	:help compl-omni
"===end 补全===

"下面是vim-airline的配置
set laststatus=2
let g:airline_powerline_fonts = 1
let g:bufferline_echo = 0
set t_Co=256

"emmet配置和使用
let g:user_emmet_install_global=0
autocmd Filetype html,css EmmetInstall
"USE:
"默认<C-y>展开，也就是先按ctrl+y然后再按,
"使用方法在http://blog.wpjam.com/m/emmet-grammar/

"AuthorInfo使用,<F2>添加
let g:vimrc_author='leetking'
let g:vimrc_email='li_Tking@163.com'
let g:vimrc_homepage=''
nmap <F2> :AuthorInfoDetect<cr>

"vimIM配置
let g:vimim_cloud = 'sogou, baidu, qq'
let g:vimim_map = 'tab_as_gi'
let g:vimim_toggle = 'pinyin, goole, sogou'
"let g:vimim_mode = 'dynamic'
"let g:vimim_mycloud = 0
"let g:vimim_shuangpin = 0

"neocomplete 配置
"Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
	"这个好像影响iab缩写诶
"inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
	return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
	" For no inserting <CR> key.
	"return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction
" <TAB>: completion.
" 我不使用tab补全
"inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
" TODO 这里设置成ctrl+h删除一个字符，而不是智能删除
"inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

" AutoComplPop like behavior.自动选择
let g:neocomplete#enable_auto_select = 1

" Shell like behavior(not recommended).
"set completeopt+=longest
let g:neocomplete#enable_auto_select = 1
"let g:neocomplete#disable_auto_complete = 1
"inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
"添加java补全
"autocmd FileType java setlocal omnifunc=javacomplete#Complete
"对于java 导入三方包R.java，可以这么写
"if filereadable("xxxx.xml")
"let g:JavaComplete_SourcesPath="xxxx/xxxx/xxx/r"
"endif

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
"let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
"let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
"neocomplete补全配置结束

"c语言模板插入
iab chead #include <stdio.h><CR><CR>int main(int argc, char **argv)<CR>{<CR>return 0;<CR>}<CR>
iab cshead using System;<CR>using System.Collections.Generic;<CR>using System.Text;<CR>using System.Collections;<CR>using System.Runtime.InteropServices;<CR><CR>namespace xx {<CR>}<CR>
iab pyhead #!/usr/bin/env python<CR>#-*-coding:utf-8-*-<CR>

"添加库函数gtk补全的路径
"set path+=/usr/include/gtk-2.0/
"设置行长80字符自动换行
"set textwidth=80 fo+=Mm
"set novisualbell
"source $HOME/.vim/syntax/hi_tag.vim
"syntax keyword <group name> <keyword list>

match Todo /\<NOTE\>/
"对于markdown文档的行末空格进行高亮	等价于(>=\S) +$ 但是目前不知道markdown的类型
highlight WhitespaceEOF ctermbg=cyan guibg=cyan
2match WhitespaceEOF /\(\S\)\@<=\ \+$/
